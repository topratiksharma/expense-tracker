import {v4 as uuidv4} from 'uuid'
import faker from 'faker'

/**
 * Shape of a expense.
 */
export interface Expense {
  /**
   * Automatically generated by the "backend".
   */
  id: string

  /**
   * ISO 8601
   */
  createdAt: string

  /**
   * Name of file that was uploaded for the expense.
   */
  filename: string

  /**
   * The expense's current status. See `ExpenseStatus` for a description of a expense's
   * life cycle.
   */
  status: ExpenseStatus

  /**
   * When uploaded, this field will be `null`. When expense analysis completes, it
   * will be populated with the vendor's name.
   */
  vendorName: string | null

  /**
   * When uploaded, this field will be `null`. When expense analysis completes, it
   * will be populated with the amount due.
   */
  amount: string | null
}

/**
 * Newly uploaded expenses start out as being analyzed. After a period of time,
 * they become unpaid. When a user marks them as such, they become paid.
 */
export enum ExpenseStatus {
  ANALYZING = 'ANALYZING',
  UNPAID = 'UNPAID',
  PAID = 'PAID',
}

/**
 * Fake implementation of a primitive API that handles expenses.
 */
class RogerApiClient {
  private listeners = new Map<string, Set<Listener>>()

  /**
   * Finds a single expense by its ID and resolves with it. Will reject if the expense
   * does not exist.
   */
  async getExpense(expenseId: string): Promise<Expense> {
    await randomWait()
    const storage = this.getExpensesStorage()
    if (!storage[expenseId]) {
      throw new Error(`Expense '${expenseId}' not found`)
    }
    return storage[expenseId]
  }

  /**
   * Resolves with a list of all expenses sorted by `createdAt` in descending
   * order.
   */
  async listExpenses(): Promise<Expense[]> {
    await randomWait()
    const storage = this.getExpensesStorage()
    return Object.values(storage).sort((a, b) =>
      b.createdAt.localeCompare(b.createdAt)
    )
  }

  /**
   * Takes a `File` object, which the user has selected for upload. Uploads the
   * file (which takes a few seconds), and then resolves with a new `Expense`
   * object with status=ANALYZING.
   *
   * After a random period of time, the expense will be analyzed and be marked as
   * paid. Listen for `expenseAnalyzed` events through the `on` method.
   */
  async uploadExpense(file: File): Promise<Expense> {
    await randomWait(2000, 4000)

    // Insert expense
    const expense: Expense = {
      id: uuidv4(),
      createdAt: new Date().toISOString(),
      filename: file.name,
      status: ExpenseStatus.ANALYZING,
      vendorName: null,
      amount: null,
    }
    this.updateExpensesStorage((storage) => {
      storage[expense.id] = expense
      return storage
    })

    // After a random timeout, we're done analyzing
    setTimeout(() => {
      this.updateExpensesStorage((storage) => {
        const b = storage[expense.id]
        if (b) {
          b.status = ExpenseStatus.UNPAID
          b.vendorName = faker.company.companyName()
          b.amount = faker.commerce.price()
        }
        return storage
      })
      const storage = this.getExpensesStorage()
      this.emit('expenseAnalyzed', storage[expense.id])
    }, randomLatency(3000, 8000))

    // Return the expense
    return expense
  }

  /**
   * Updates a single expense. Only keys included in `changes` are changed - other
   * keys are left intact. Resolves with updated `Expense` object. Rejects if expense
   * does not exist.
   */
  async patchExpense(
    expenseId: string,
    changes: Partial<Expense>
  ): Promise<Expense> {
    await randomWait()
    this.updateExpensesStorage((storage) => {
      if (!storage[expenseId]) {
        throw new Error(`Expense '${expenseId}' not found`)
      }
      Object.assign(storage[expenseId], changes)
      return storage
    })
    return this.getExpensesStorage()[expenseId]
  }

  /**
   * Deletes a expense and resolves when successful. Idempotent.
   */
  async deleteExpense(expenseId: string): Promise<void> {
    await randomWait()
    this.updateExpensesStorage((storage) => {
      delete storage[expenseId]
      return storage
    })
  }

  /**
   * Resets the database by deleting all expenses.
   */
  async reset(): Promise<void> {
    this.updateExpensesStorage(() => ({}))
  }

  /**
   * Register a listener for events from the "back-end". `listener` will be
   * called when events of the given `eventName` are emitted. The following
   * events are supported:
   *
   * - `expenseAnalyzed`: Called when analisis completes for a expense. Listener will
   *   be called with the `Expense` object that was updated.
   */
  on(eventName: 'expenseAnalyzed', listener: (expense: Expense) => void): void
  on(eventName: string, listener: Listener): void {
    let eventListeners = this.listeners.get(eventName)
    if (!eventListeners) {
      eventListeners = new Set()
      this.listeners.set(eventName, eventListeners)
    }
    eventListeners.add(listener)
  }

  /**
   * Removes a listener previously registered with `on`.
   */
  off(eventName: string, listener: Listener) {
    let eventListeners = this.listeners.get(eventName)
    if (eventListeners) {
      eventListeners.delete(listener)
    }
  }

  private emit(eventName: 'expenseAnalyzed', expense: Expense): void
  private emit(eventName: string, ...args: any[]): void {
    let eventListeners = this.listeners.get(eventName)
    if (eventListeners) {
      eventListeners.forEach((listener) => listener(...args))
    }
  }

  private getExpensesStorage(): ExpensesStorage {
    const raw = localStorage.getItem('roger-tht-expenses')
    if (!raw) {
      return {}
    }
    return JSON.parse(raw)
  }

  private updateExpensesStorage(
    callback: (storage: ExpensesStorage) => ExpensesStorage
  ) {
    const storage = callback(this.getExpensesStorage())
    localStorage.setItem('roger-tht-expenses', JSON.stringify(storage))
  }
}

export const client = new RogerApiClient()

// Utility types and functions
type Listener = (...args: any[]) => void

type ExpensesStorage = {[id: string]: Expense}

function randomLatency(min: number = 200, max: number = 500) {
  return process.env.NODE_ENV === 'test'
    ? 1
    : Math.round(min + Math.random() * max)
}

async function randomWait(min: number = 200, max: number = 500) {
  await new Promise((resolve) =>
    window.setTimeout(resolve, randomLatency(min, max))
  )
}
